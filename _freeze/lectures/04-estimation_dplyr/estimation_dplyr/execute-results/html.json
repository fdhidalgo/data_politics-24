{
  "hash": "08b211e25c44eb1299c8487b22dcdf52",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Estimation of Causal Effects<BR>and Data Manipulation in `R`\"\nsubtitle: \"Lecture 4\"\ndate: last-modified\nauthor: \n  - name: F. Daniel Hidalgo\n    email: dhidalgo@mit.edu\n    affiliations: MIT\nformat: clean-revealjs\nengine: knitr\nwebr:\n  packages: ['ggplot2', 'dplyr', 'gapminder'] # Install R packages on document open\n  show-startup-message: false\nfilters: \n  - timer\n  - webr\nbibliography: ../data_politics_2024.bib\neditor:\n  render-on-save: true\n---\n\n::: {.cell}\n\n:::\n\n\n# Estimation of Causal Effects\n\n## Potential Outcomes\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n## Potential Outcomes\npo <- tibble(\n  X = rnorm(n = 50, mean = 2, sd = 2),\n  Y0 = rnorm(50, 10, 5) +\n    5 * X,\n  Y1 = Y0 + 3\n)\n\nhead(po)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 3\n       X    Y0    Y1\n   <dbl> <dbl> <dbl>\n1 0.0677  6.19  9.19\n2 3.09   28.4  31.4 \n3 1.11   15.4  18.4 \n4 3.74   20.0  23.0 \n5 2.01   18.0  21.0 \n6 0.577  18.3  21.3 \n```\n\n\n:::\n:::\n\n:::\n\n::: {.column .fragment width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\npivot_longer(po, cols = c(Y0, Y1), names_to = \"Y\") |>\n  ggplot(aes(x = value, color = Y, fill = Y)) +\n  geom_density(alpha = .3) +\n#  theme_minimal() +\n  labs(title = \"Potential Outcomes\",\n       x = \"Outcome\",\n       y = \"Density\") +\n  theme(legend.position = \"bottom\") +\n  scale_fill_ipsum() +\n  scale_color_ipsum()\n```\n\n::: {.cell-output-display}\n![](estimation_dplyr_files/figure-revealjs/potential_outcomes_plot-1.png){width=960}\n:::\n:::\n\n:::\n:::\n\n## A Single Draw\n\n\n::: {.cell}\n\n```{.r .cell-code}\npo$D <- sample(c(0, 1), 50, replace = TRUE)\npo$Y <- po$D * po$Y1 + (1 - po$D) * po$Y0\n\nest_ate <- mean(po$Y[po$D == 1]) -\n  mean(po$Y[po$D == 0])\n\nest_ate\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -2.040671\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndraws <- ggplot() +\n  xlim(-1,7) +\n  ylim(0,1) +\n  geom_point(aes(x = 3, y = .5), size = 5,  color = \"orange\") +\n  geom_point(aes(x = est_ate, y = .5), size = 5, color = \"darkgray\") +\n# remove y-axis \n  theme(axis.title.y=element_blank(),\n        axis.text.y=element_blank(),\n        axis.ticks.y=element_blank()) \n  \n\ndraws\n```\n\n::: {.cell-output-display}\n![](estimation_dplyr_files/figure-revealjs/estimation_plot-1.png){width=1920}\n:::\n:::\n\n\n## Another Draw\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nestim_ate <- function(data){\n  data$D <- sample(c(0, 1), 50, replace = TRUE)\n  data$Y <- data$D * data$Y1 + (1 - data$D) * data$Y0\n  mean(data$Y[data$D == 1]) -\n    mean(data$Y[data$D == 0])\n}\n\nanother_draw <- estim_ate(po)\nanother_draw\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.791896\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndraws <- draws +\n  geom_point(aes(x = another_draw, y = .5), size = 5, color = \"darkgray\")\n\ndraws\n```\n\n::: {.cell-output-display}\n![](estimation_dplyr_files/figure-revealjs/another_draw_plot-1.png){width=1920}\n:::\n:::\n\n\n## Many Draws\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestimates <- replicate(1000, estim_ate(po))\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nests_df <- tibble(draw = 1:1000, \n                  ests = estimates)\nests_df |>\nggplot() +\n  xlim(min(ests_df$ests), max(ests_df$ests)) +\n  ylim(0,1) +\n  geom_point(aes(x = ests, y = .5, group = draw), size = 5, color = \"darkgray\") +\n  geom_point(aes(x = 3, y = .5), size = 10,  color = \"orange\") +\n# remove y-axis \n  theme(axis.title.y=element_blank(),\n        axis.text.y=element_blank(),\n        axis.ticks.y=element_blank()) +\n  transition_reveal(draw)\n```\n\n::: {.cell-output-display}\n![](estimation_dplyr_files/figure-revealjs/many_draws_plot-1.gif)\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(estimates)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.984171\n```\n\n\n:::\n:::\n\n\n## Expectations\n\nThe [**expectation**]{.alert} of a discrete random variable $Y$ is given by: $$E[Y] = \\sum y \\Pr[Y=y]$$ \n\n. . .\n\nThe [**conditional expectation**]{.alert} of $Y$ given $X$ is given by: $$E[Y|X] = \\sum y \\Pr[Y=y|X=x] $$\n\n## Estimand\n\nThe [**average treatment effect**]{.alert} (ATE) is given by: $$\n\\begin{align*}\n\\tau &= E[Y(1) - Y(0)] = E[Y(1)] - E[Y(0)]  \\\\\n&= \\frac{1}{N} \\sum_{i=1}^N (Y_i(1) - Y_i(0)) \\equiv \\textrm{ATE}\n\\end{align*}\n$$\n\nThis is the number we want to **estimate**.\n\n## Random Assignment and Unbiased Inference\n\nBecause random assignment ensures that potential outcomes are **independent** of treatment assignment, we have that:\n\n$$E[Y(1)|D=1] = E[Y(1)|D=0] = E[Y(1)]$$\n\n$$E[Y(0)|D=1] = E[Y(0)|D=0] = E[Y(0)]$$\n\n. . .\n\nAs a result: $$\\textrm{ATE} = E[Y(1)] - E[Y(0)] = E[Y(1)|D=1] - E[Y(0)|D=0]$$\n\n## Estimation\n\nWe need to estimate $E[Y(1)|D=1]$ and $E[Y(0)|D=0]$.\n\nUnder simple random assignment, we can estimate these quantities using the sample **means** of the treated and control groups:\n\n. . .\n\n$$\n\\begin{align}\nE\\left[\\frac{\\sum_{i=1}^{m} Y_i}{m} - \\frac{\\sum_{i=m+1}^{N} Y_i}{N - m}\\right] &= E\\left[\\frac{\\sum_{i=1}^{m} Y_i}{m}\\right] - E\\left[\\frac{\\sum_{i=m+1}^{N} Y_i}{N - m}\\right] \\\\\n&= E[Y_i(1) | D_i = 1] - E[Y_i(0) | D_i = 0] \\\\\n&= E[Y_i(1)] - E[Y_i(0)] \\\\\n&= E[\\tau_i] = \\text{ATE}.\n\\end{align} \n$$\n\n## Unbiased Estimation\n\n::: columns\n::: {.column width=\"50%\"}\n\nOur [**estimator**]{.alert} is the *difference-in-means*. \n\nOur [**estimator**]{.alert} is unbiased if over repeated randomization, the expected value of the estimator is equal to the true value of the [**estimand**]{.alert}.\n\n:::\n\n::: {.column .fragment width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nests_df |>\n  ggplot() +\n  geom_histogram(aes(x = ests), bins = 30, fill = \"lightblue\", color = \"black\") +\n  geom_vline(aes(xintercept = 3), color = \"orange\", linewidth = 2) +\n  labs(title = \"Distribution of Estimates\",\n       x = \"Estimate\",\n       y = \"Frequency\")\n```\n\n::: {.cell-output-display}\n![](estimation_dplyr_files/figure-revealjs/ests_hist-1.png){width=960}\n:::\n:::\n\n\n\n:::\n:::\n\n## Covariate Balance\n::: columns\n::: {.column width=\"50%\"}\n\nWe can use *pre-treatment* [**covariates**]{.alert} $X$ to identify bad draws. \n\nIf $X$ is predictive of outcomes and we find that $X$ is not *balanced* across treatment and control groups, then  our **estimate** might be far from our  **estimand**.\n\n:::\n\n::: {.column .fragment width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nestim_ate_bal <- function(data){\n  data$D <- sample(c(0, 1), 50, replace = TRUE)\n  data$Y <- data$D * data$Y1 + (1 - data$D) * data$Y0\n  tibble(est_y = mean(data$Y[data$D == 1]) - mean(data$Y[data$D == 0]),\n         est_x = mean(data$X[data$D == 1]) - mean(data$X[data$D == 0]))\n}\n\nests <- map(1:1000, ~estim_ate_bal(po)) |>\n  bind_rows()\n\nests |>\n  ggplot() +\n  geom_point(aes(x = est_x, y = est_y), color = \"lightblue\") +\n  geom_smooth(aes(x = est_x, y = est_y), method = \"lm\", color = \"red\",\n              se = FALSE) +\n  geom_hline(yintercept = 3, color = \"orange\", linetype = \"dashed\", size = 3) +\n  labs(title = \"ATE Estimates and Covariate Balance\",\n       x = \"Covariate Balance\",\n       y = \"Estimate\",\n       caption = \"Orange line is the true ATE\")\n```\n\n::: {.cell-output-display}\n![](estimation_dplyr_files/figure-revealjs/covariate_balance-1.png){width=960}\n:::\n:::\n\n\n\n:::\n:::\n\n# Data Wrangling with `dplyr`\n\n## Messy Data\n\n- Data almost **never** comes in the form we need\n\n- The potential problems are endless:\n  - Missing values\n  - Need to transform the variable in some way\n  - Need to summarize within groups\n  - Need to rename the variables\n  - Need to reorder the data\n\n- Today we will learn how to use the `dplyr` package to solve these problems\n\n## The `dplyr` Package\n\n:::: columns\n\n::: {.column width=\"30%\"}\n![](images/dplyr.png)\n:::\n\n::: {.column width=\"70%\" }\n\n- `dplyr` is a set of functions for data manipulation. These functions:\n\n  - Take a dataset as their input\n  - Manipulate the dataset in some way\n  - Return a new dataset as their output\n\n:::\n\n::::\n\n## The Pipe\n\nNested calls can be hard to read:\n\n```r\nmean(sd(log(x)))\n```\n\nThe pipe operator (`|>`) allows us to write this as:\n\n```r\nx |> \n  log() |> \n  sd() |> \n  mean()\n```\n\n## Operating on Rows\n\n `filter()`: subset rows based on a condition\n \n ![](images/filter.png)\n \n## `filter`\n \n```{webr-r}\n#| label: filter\n#| echo: true\n\nlibrary(gapminder)\n\ngapminder |> \n  filter(country == \"Brazil\")\n\n```\n \n## Logicals\n\n- Comparing two values/vectors: \n  - `>` or `>=`: greater than or equal to\n  - `<` or `<=`: less than or equal to\n  - `==` or `!=`: equal to or not equal to\n  \n- Combining multiple logical conditions:\n  - `&`: and\n  - `|`: or\n  - `!`: not\n  \n## Multiple Conditions\n\n```{webr-r}\n\ngapminder |> \n  filter(country == \"Brazil\" & year == 2007)\n\n```\n\n## Combining `%in%`\n\nWhen combining `|` and `==`, useful to use `%in%`:\n\n```{webr-r}\n\ngapminder |> \n  filter(country %in% c(\"Brazil\", \"Argentina\") & year == 2007)\n\n```\n\n## Arrange\n\n`arrange()`: reorder rows based on a variable.\n\nWith multiple variables, `arrange()` will sort by the first variable, then the second, and so on.\n\n```{webr-r}\n\ngapminder |> \n  arrange(year, country)\n\n```\n\n## Rich and Poor Countries\n\nWhich country years have the highest and lowest GDP per capita?\n\n```{webr-r}\n\ngapminder |> \n  arrange(gdpPercap)\n\n```\n\nUse `desc()` to sort in descending order:\n\n```{webr-r}\n\ngapminder |> \n  arrange(desc(gdpPercap))\n\n```\n\n## Operating on columns\n\n`select()`: subset columns based on their names\n\n```{webr-r}\n\ngapminder |> \n  select(country, year, gdpPercap)\n\n```\n\n## `rename`\n\n`rename()`: rename columns\n\n```{webr-r}\n\ngapminder |> \n  rename(population = pop)\n\n```\n\n## `mutate`\n\n![](images/mutate.png)\n\n\n## `mutate`\n\n`mutate()`: add new variables or modify existing ones\n\n\n```{webr-r}\n\ngapminder |> \n  mutate(gdp = gdpPercap * pop)\n\n```\n\n## `ifelse`\n\n`ifelse(test, yes, no)`: a vectorized if-else statement\n\nNew vector is `yes` where `test` is `TRUE`, and `no` where `test` is `FALSE`\n\n```{webr-r}\n\ngapminder |> \n  mutate(high_gdp = ifelse(gdpPercap > 10000, \"High\", \"Low\"))\n\n\n```\n\n## `group_by`\n\n`group_by()`: group the data by one or more variables\n\nDoesn't change the data, but tells `dplyr` that you want to operate on the data in groups\n\n```{webr-r}\n\ngapminder |> \n  group_by(country) \n\n```\n\n## `summarize`\n\n`summarize()`: collapse each group into a single row\n\n```{webr-r}\n\ngapminder |>\n  filter(year == 2007) |>\n  group_by(continent) |>\n  summarize(mean_gdp = mean(gdpPercap),\n            total_pop = sum(pop))\n\n```\n\n## `mutate` and `group_by`\n\n`mutate()` and `group_by()` can be used together to create new variables that are calculated within groups\n\n```{webr-r}\n\ngapminder |>\n  filter(year == 2007) |>\n  group_by(continent) |>\n  mutate(rank = rank(desc(gdpPercap)))\n\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}